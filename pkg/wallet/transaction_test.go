package wallet

import (
	"encoding/hex"
	"testing"
	"time"

	"github.com/knd/kndchain/pkg/crypto"
	"github.com/knd/kndchain/pkg/hashing"
	"github.com/stretchr/testify/assert"
)

func TestTransaction_HasAutoGeneratedID(t *testing.T) {
	m := new(MockedKeyPairGenerator)
	m.On("Generate").Return([]byte{}, []byte{})

	// perform test
	tx := NewTransaction(NewWallet(m), "receiver", 0)

	// test verification
	assert.NotEmpty(t, tx.GetID())
}

func TestTransaction_OutputHasAmountToReceiver(t *testing.T) {
	m := new(MockedKeyPairGenerator)
	m.On("Generate").Return([]byte{}, []byte{})

	// perform test
	tx := NewTransaction(NewWallet(m), "receiver", 1)

	// test verification
	assert.Equal(t, uint64(1), tx.GetOutput()["receiver"])
}

func TestTransaction_OutputHasRemainingBalanceOfSenderWallet(t *testing.T) {
	m := new(MockedKeyPairGenerator)
	senderPubKey := []byte("pubkey-sender")
	m.On("Generate").Return(senderPubKey, []byte{})
	w := NewWallet(m)

	// perform test
	tx := NewTransaction(w, "receiver", 1)

	// test verification
	assert.Equal(t, uint64(999), tx.GetOutput()[w.PubKeyHex()])
}

func TestTransaction_Input(t *testing.T) {
	assert := assert.New(t)
	secp256k1 := crypto.NewSecp256k1Generator()
	senderWallet := NewWallet(secp256k1)
	receiverWallet := NewWallet(secp256k1)

	// perform test
	tx := NewTransaction(senderWallet, receiverWallet.PubKeyHex(), 99)

	t.Run("has timestamp", func(t *testing.T) {
		assert.NotZero(tx.GetInput().Timestamp)
	})

	t.Run("sets `amount` to the `senderWallet` balance", func(t *testing.T) {
		assert.Equal(InitialBalance, tx.GetInput().Amount)
	})

	t.Run("sets `address` to the `senderWallet` pubKey", func(t *testing.T) {
		assert.Equal(senderWallet.PubKeyHex(), tx.GetInput().Address)
	})

	t.Run("signs the input with senderWallet privKey", func(t *testing.T) {
		ob, _ := hex.DecodeString(hashing.SHA256Hash(tx.GetOutput()))

		assert.True(secp256k1.Verify(senderWallet.PubKey(), ob, tx.GetInput().Signature))
	})
}

func TestIsValidTransaction(t *testing.T) {
	assert := assert.New(t)

	t.Run("returns true if tx is valid", func(t *testing.T) {
		secp256k1 := crypto.NewSecp256k1Generator()
		senderWallet := NewWallet(secp256k1)
		receiverWallet := NewWallet(secp256k1)
		tx := NewTransaction(senderWallet, receiverWallet.PubKeyHex(), 99)

		// perform test
		valid, _ := IsValidTransaction(tx)

		// test verification
		assert.True(valid)
	})

	t.Run("returns false if tx ouptut is invalid", func(t *testing.T) {
		iT := time.Now().Unix()
		senderPubKeyHex := "0x123"
		receiverPubKeyHex := "0x456"
		tx := new(MockedTransaction)
		var s [65]byte
		copy(s[:], []byte("data"))
		tx.On("GetInput").Return(TxInput{
			Timestamp: iT,
			Amount:    1000,
			Address:   senderPubKeyHex,
			Signature: s[:],
		})
		tx.On("GetOutput").Return(TxOutput{
			senderPubKeyHex:   991,
			receiverPubKeyHex: 10,
		})

		// perform test
		valid, err := IsValidTransaction(tx)

		// test verification
		assert.False(valid)
		assert.Equal(ErrInvalidOutputTotalBalance, err)
	})

	t.Run("returns false if tx input signature invalid", func(t *testing.T) {
		iT := time.Now().Unix()
		secp256k1 := crypto.NewSecp256k1Generator()
		senderWallet := NewWallet(secp256k1)
		receiverWallet := NewWallet(secp256k1)
		tx := new(MockedTransaction)
		var s [65]byte
		copy(s[:], []byte("data"))
		tx.On("GetInput").Return(TxInput{
			Timestamp: iT,
			Amount:    1000,
			Address:   senderWallet.PubKeyHex(),
			Signature: s[:],
		})
		tx.On("GetOutput").Return(TxOutput{
			senderWallet.PubKeyHex():   uint64(990),
			receiverWallet.PubKeyHex(): uint64(10),
		})

		// perform test
		valid, err := IsValidTransaction(tx)

		// test verification
		assert.False(valid)
		assert.Equal(ErrInvalidSignature, err)
	})

	t.Run("returns false if tx input signature is signed by different key", func(t *testing.T) {
		iT := time.Now().Unix()
		secp256k1 := crypto.NewSecp256k1Generator()
		senderWallet := NewWallet(secp256k1)
		receiverWallet := NewWallet(secp256k1)
		tx := new(MockedTransaction)
		output := TxOutput{
			senderWallet.PubKeyHex():   uint64(990),
			receiverWallet.PubKeyHex(): uint64(10),
		}
		tx.On("GetOutput").Return(output)
		outputBytes, _ := hex.DecodeString(hashing.SHA256Hash(output))
		tx.On("GetInput").Return(TxInput{
			Timestamp: iT,
			Amount:    1000,
			Address:   senderWallet.PubKeyHex(),
			Signature: receiverWallet.Sign(outputBytes),
		})

		// perform test
		valid, err := IsValidTransaction(tx)

		// test verification
		assert.False(valid)
		assert.Equal(ErrInvalidSignature, err)
	})
}

func TestTransaction_Append(t *testing.T) {
	assert := assert.New(t)
	secp256k1 := crypto.NewSecp256k1Generator()
	senderWallet := NewWallet(secp256k1)
	receiverAWallet := NewWallet(secp256k1)
	receiverBWallet := NewWallet(secp256k1)
	tx := NewTransaction(senderWallet, receiverAWallet.PubKeyHex(), 10)

	originalSignature := tx.GetInput().Signature

	// perform test
	tx.Append(senderWallet, receiverBWallet.PubKeyHex(), 20)

	t.Run("returns error if append amount is greater than sender current output balance", func(t *testing.T) {
		assert.Equal(ErrAmountExceedsBalance, tx.Append(senderWallet, receiverBWallet.PubKeyHex(), 971))
	})

	t.Run("outputs the amount to receiver B", func(t *testing.T) {
		assert.Equal(uint64(20), tx.GetOutput()[receiverBWallet.PubKeyHex()])
	})

	t.Run("outputs updated remaining amount of sender", func(t *testing.T) {
		assert.Equal(uint64(970), tx.GetOutput()[senderWallet.PubKeyHex()])
	})

	t.Run("maintains total output balance that matches input amount", func(t *testing.T) {
		var oBalance uint64
		for _, a := range tx.GetOutput() {
			oBalance += a
		}

		assert.Equal(tx.GetInput().Amount, oBalance)
	})

	t.Run("resigns the transaction in tx input", func(t *testing.T) {
		assert.NotEqual(tx.GetInput().Signature, originalSignature)
	})

	t.Run("updates the receiverB output amount", func(t *testing.T) {
		err := tx.Append(senderWallet, receiverBWallet.PubKeyHex(), 10)

		assert.Nil(err)
		assert.Equal(int(10), int(tx.GetOutput()[receiverAWallet.PubKeyHex()]))
		assert.Equal(int(960), int(tx.GetOutput()[senderWallet.PubKeyHex()]))
		assert.Equal(int(30), int(tx.GetOutput()[receiverBWallet.PubKeyHex()]))
	})
}
